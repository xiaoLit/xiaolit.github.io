<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Xcode10与libstdc++</title>
      <link href="/2018/11/14/Xcode10%E4%B8%8Elibstdc/"/>
      <url>/2018/11/14/Xcode10%E4%B8%8Elibstdc/</url>
      
        <content type="html"><![CDATA[<p>众所周知Xcode10中删除的libstdc++库，并且手动导入的话每一次Xcode10升级会自动再次删除。需要再次手动导入。所以找个简单点的方法，虽然还是要每次导入但只需要以下文件和一行代码。</p><p><a href="https://github.com/xiaoLit/libstdc-" target="_blank" rel="noopener">需要下载的库</a><br><code>cd</code>到路径<code>libstdc</code><br><code>sudo sh install.sh</code> </p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>iOS截屏和控件截取</title>
      <link href="/2018/11/08/iOS%E6%88%AA%E5%B1%8F/"/>
      <url>/2018/11/08/iOS%E6%88%AA%E5%B1%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="先上干货懒得看的直接跑Demo。"><a href="#先上干货懒得看的直接跑Demo。" class="headerlink" title="先上干货懒得看的直接跑Demo。"></a>先上干货懒得看的直接跑<a href="https://github.com/xiaoLit/LitShotScreen" target="_blank" rel="noopener">Demo</a>。</h4><hr><p>iOS7之后，苹果开放出一个通知：UIApplicationUserDidTakeScreenshotNotification，截屏时系统就会发出这个通知，需要你注册这个通知，就能捕捉到截屏图片。</p><pre><code> [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(getScreenShot:) name:UIApplicationUserDidTakeScreenshotNotification object:nil];</code></pre><pre><code>/** 通知回调 */- (void)getScreenShot:(NSNotification *)notification{   //获取截屏图片    UIImage *image = [UIImage imageWithData:[self imageDataFromScreenShot]];}</code></pre><p><strong>获取截图的方法有很多</strong></p><h4 id="方法一、-用于全屏截图最稳妥的方法目前iOS12-1也可以使用不过效率低些"><a href="#方法一、-用于全屏截图最稳妥的方法目前iOS12-1也可以使用不过效率低些" class="headerlink" title="方法一、 用于全屏截图最稳妥的方法目前iOS12.1也可以使用不过效率低些"></a><strong>方法一、</strong> 用于全屏截图最稳妥的方法目前iOS12.1也可以使用不过效率低些</h4><pre><code>/** 获取截屏 */- (NSData *)imageDataFromScreenShot {   /**     创建一个基于位图的上下文（context）,并将其设置为当前上下文(context)     @param size 参数size为新创建的位图上下文的大小。它同时是由UIGraphicsGetImageFromCurrentImageContext函数返回的图形大小     @param opaque 透明开关，如果图形完全不用透明，设置为YES以优化位图的存储，我们得到的图片背景将会是黑色，使用NO，表示透明，图片背景色正常     @param scale 缩放因子 iPhone 4是2.0，其他是1.0。虽然这里可以用[UIScreen mainScreen].scale来获取，但实际上设为0后，系统就会自动设置正确的比例了     */    UIGraphicsBeginImageContextWithOptions([UIScreen mainScreen].bounds.size, NO, 0);    //获取当前上下文    CGContextRef context = UIGraphicsGetCurrentContext();    //遍历所有窗口 用于完善处理一些多层windows显示问题    for (UIWindow *window in [[UIApplication sharedApplication] windows]) {        if ([window respondsToSelector:@selector(drawViewHierarchyInRect:afterScreenUpdates:)]) {            [window drawViewHierarchyInRect:window.bounds afterScreenUpdates:YES];        } else {            [window.layer renderInContext:context];        }    }    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();    UIGraphicsEndImageContext();    return UIImagePNGRepresentation(image);}</code></pre><p><strong>注意：</strong>iOS 7上UIView上提供了drawViewHierarchyInRect:afterScreenUpdates:来截图，速度比renderInContext:快15倍</p><p><strong>配合剪裁图片我们可以获得更加合适截图区域</strong></p><pre><code>/** 剪裁图片 */- (UIImage *)clipImage:(UIImage *)shotView {    //上面我们获得了一个全屏的截图，下边的方法是对这个图片进行裁剪。    CGImageRef imageRef = shotView.CGImage;    //这里要特别注意，这里的宽度 CGImageGetWidth(imageRef) 是图片的像素宽（高度同解），所以计算截图区域时需要按比例来；    //这里举的例子是宽高屏幕1/2位置在中心    CGRect rect =  CGRectMake(CGImageGetWidth(imageRef)/4, CGImageGetHeight(imageRef)/2-CGImageGetWidth(imageRef)/2, CGImageGetWidth(imageRef)/2, CGImageGetWidth(imageRef)/2);//这里可以设置想要截图的区域    CGImageRef imageRefRect =CGImageCreateWithImageInRect(imageRef, rect);    UIImage *clipImage =[[UIImage alloc] initWithCGImage:imageRefRect];    return clipImage;}</code></pre><h4 id="方法二、-适用于单个控件截图"><a href="#方法二、-适用于单个控件截图" class="headerlink" title="方法二、  适用于单个控件截图"></a><strong>方法二、</strong>  适用于单个控件截图</h4><pre><code>/** 截图控件 */- (UIView *)customSnapshotFromView:(UIView *)inputView {    UIGraphicsBeginImageContextWithOptions(inputView.frame.size, NO, 0.0);    //把控制器View的内容绘制到上下文当中.    CGContextRef context =UIGraphicsGetCurrentContext();    //layer是不能够直接绘制的.要用渲染的方法才能够让它绘制到上下文当中。UIGraphicsGetCurrentContext()    [inputView.layer renderInContext:context];    //从上下文当中生成一张图片    UIImage*targetImage =UIGraphicsGetImageFromCurrentImageContext();    UIGraphicsEndImageContext();    UIImageView*imageView = [[UIImageView alloc]initWithImage:targetImage];    imageView.frame= inputView.frame;    return imageView;}</code></pre><h4 id="方法三、-iOS7就支持非常便捷的截图方法snapshotViewAfterScreenUpdates"><a href="#方法三、-iOS7就支持非常便捷的截图方法snapshotViewAfterScreenUpdates" class="headerlink" title="方法三、  iOS7就支持非常便捷的截图方法snapshotViewAfterScreenUpdates"></a><strong>方法三、</strong>  iOS7就支持非常便捷的截图方法snapshotViewAfterScreenUpdates</h4><pre><code>- (UIView *)customSnapshotFromView:(UIView *)inputView {    //afterUpdates参数表示是否在所有效果应用在视图上了以后再获取快照。    //例如，如果该参数为NO，则立马获取该视图现在状态的快照，反之，以下代码只能得到一个空白快照：    UIView *snapshot = [inputView snapshotViewAfterScreenUpdates:YES];    snapshot.layer.masksToBounds = YES;    return snapshot;}</code></pre><p>但是据说iOS10之后就不好使了，我用的iOS12测试发现和iOS9模拟器都无法使用，所以现在使用的话此方法有待考察。</p><hr><p>有可能有特殊的情况,会要求横屏等其他方向截屏变成正常竖屏样式展示，将截屏的图片进行仿射变换就可以了。Demo也有相关代码。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>使用hexo-theme-material主题的一些心得</title>
      <link href="/2018/10/09/Material/"/>
      <url>/2018/10/09/Material/</url>
      
        <content type="html"><![CDATA[<h2 id="material-1-5-5和1-5-6版本使用过程中出现报错。a"><a href="#material-1-5-5和1-5-6版本使用过程中出现报错。a" class="headerlink" title="material-1.5.5和1.5.6版本使用过程中出现报错。a"></a>material-1.5.5和1.5.6版本使用过程中出现报错。a</h2><p>解决方案<a href="https://github.com/viosey/hexo-theme-material/issues/686" target="_blank" rel="noopener">issue#686</a>。<br>修改layout/_widget/dnsprefetch.ejs文件。修改内容如下：</p><pre><code>&lt;% } else if(theme.comment.use.startsWith(&quot;disqus&quot;)) { %&gt;修改为&lt;% } else if(theme.comment.use &amp;&amp; theme.comment.use.startsWith(&quot;disqus&quot;)) { %&gt;</code></pre><h2 id="博客本地搜索功能"><a href="#博客本地搜索功能" class="headerlink" title="博客本地搜索功能"></a>博客本地搜索功能</h2><p>安装<code>hexo-generator-search</code><br><code>$ npm install hexo-generator-search --save</code><br>修改文件:博客/themes/material/_config.yml</p><pre><code>search:    use: local</code></pre><p>修改文件:博客/_config.yml</p><pre><code>search:  path: search.xml  field: post</code></pre><h2 id="新版prettify自动折行替换为不折行并添加滚动条"><a href="#新版prettify自动折行替换为不折行并添加滚动条" class="headerlink" title="新版prettify自动折行替换为不折行并添加滚动条"></a>新版prettify自动折行替换为不折行并添加滚动条</h2><p>解决方案<a href="https://github.com/viosey/hexo-theme-material/issues/616" target="_blank" rel="noopener">issues#616</a><br>把<code>source/css/prettify.css</code>直接替换为</p><pre><code>@charset &quot;UTF-8&quot;;/* for color-themes-for-google-code-prettify *//* Automatically add a scroll bar instead of a newline */pre{    white-space: pre;}#post-content .prettyprint{    padding: 1.2em;    border-radius: 0;}#post-content ol,#post-content ul{    padding-left: 32px;    font-size: 1rem;    margin: 0;    overflow: initial;}#post-content pre code, #post-content pre tt {    padding-right: 2em;}#post-content .prettyprint li.L0, #post-content .prettyprint li.L1,#post-content .prettyprint li.L2, #post-content .prettyprint li.L3,#post-content .prettyprint li.L4, #post-content .prettyprint li.L5,#post-content .prettyprint li.L6, #post-content .prettyprint li.L7,#post-content .prettyprint li.L8, #post-content .prettyprint li.L9 {    padding-left: 0.5em;}</code></pre><p><code>source/css/prettify.min.css</code>直接替换为：</p><pre><code>pre{white-space:pre}#post-content .prettyprint{padding:1.2em;border-radius:0}#post-content ol,#post-content ul{padding-left:32px;font-size:1rem;margin:0;overflow:initial}#post-content pre code,#post-content pre tt{padding-right:2em}#post-content .prettyprint li.L0,#post-content .prettyprint li.L1,#post-content .prettyprint li.L2,#post-content .prettyprint li.L3,#post-content .prettyprint li.L4,#post-content .prettyprint li.L5,#post-content .prettyprint li.L6,#post-content .prettyprint li.L7,#post-content .prettyprint li.L8,#post-content .prettyprint li.L9{padding-left:.5em}</code></pre><h2 id="去掉行号"><a href="#去掉行号" class="headerlink" title="去掉行号"></a>去掉行号</h2><p>默认hanabi是支持的，只需要</p><pre><code>hanabi:    enable: true    line_number: true</code></pre><p>可是material-1.5.5和1.5.6版本使用prettify不支持去掉行号，那么就只有暴力处理了。<br>修改<code>themes/material/layout/_partial</code> 下的文件<code>import_js.ejs</code></p><pre><code>$(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);替换为：$(&#39;pre&#39;).addClass(&#39;prettyprint&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);</code></pre><h2 id="安装prettify的正确姿势"><a href="#安装prettify的正确姿势" class="headerlink" title="安装prettify的正确姿势"></a>安装prettify的正确姿势</h2><h6 id="更新"><a href="#更新" class="headerlink" title="更新"></a><strong>更新</strong></h6><p>分割线以下安装步骤为老版的内容，1.5.5和1.5.6版本无需再用此方法。<br>直接改主题下<code>_config.yml</code>文件即可</p><pre><code>prettify:    enable: true    theme: &quot;vibrant-ink&quot;</code></pre><p>集成了大部分prettify,可在目录<code>themes/material/source/css/prettify</code>查看具体名字，觉得挨个尝试麻烦的话可以直接到<a href="https://jmblog.github.io/color-themes-for-google-code-prettify/" target="_blank" rel="noopener">这里</a>看效果然后填写目录下的相应主题名字。</p><hr><p>开始看了 <a href="https://hanyx1992.github.io/2018/05/02/helloworld/" target="_blank" rel="noopener">@韩元旭</a> 大佬的文章设置prettify发现代码块滚动条异常。于是去爬论坛，发现这个问题在<a href="https://github.com/viosey/hexo-theme-material/issues/383" target="_blank" rel="noopener">issue#383</a>中解决，并且在<a href="https://github.com/viosey/hexo-theme-material/issues/616" target="_blank" rel="noopener">issue#616</a>优化过，也就是新版本是包含的。所以猜想应该该主题支持的方式有可能不同，于是在<a href="https://github.com/viosey/hexo-theme-material/pull/395" target="_blank" rel="noopener">issue#395</a>找到了该姿势。</p><h4 id="1-安装code-prettify"><a href="#1-安装code-prettify" class="headerlink" title="1.安装code-prettify"></a>1.安装code-prettify</h4><ul><li><code>git clone https://github.com/google/code-prettify.git</code></li><li>将src重命名为prettify，然后目录prettify拷贝至你的 hexo 博客的 source/vendors/下, vendors是新建的目录</li></ul><h4 id="2-安装color-themes-for-google-code-prettify"><a href="#2-安装color-themes-for-google-code-prettify" class="headerlink" title="2. 安装color-themes-for-google-code-prettify"></a>2. 安装color-themes-for-google-code-prettify</h4><pre><code>$ cd yourproject$ npm i color-themes-for-google-code-prettify -S$ cd node_modules/color-themes-for-google-code-prettify/dist$ cp -r themes ../../../themes/material/source/vendors/prettify/</code></pre><p>其实就是安装<code>color-themes-for-google-code-prettify</code>, 将dist/themes拷贝到<code>themes/material/source/vendors/prettify/</code>下</p><h4 id="3-prettify用法"><a href="#3-prettify用法" class="headerlink" title="3. prettify用法"></a>3. prettify用法</h4><ul><li>主题下的<code>_config.template.yml</code>追加以下内容：</li></ul><pre><code>prettify:    enable: true   # if true, customcss.enable must be true    theme: &quot;vibrant-ink&quot; # default value: &quot;vibrant-ink&quot;   # &quot;theme-name without .css&quot;# custom csscustomcss:    enable: true    csspath: [  # css file path        &quot;/css/custom-prettify.min.css&quot;    ]</code></pre><ul><li>在主题下的<code>layout/_partial/head.ejs</code>追加下面内容：</li></ul><pre><code>&lt;% if (theme.prettify.enable){ %&gt;        &lt;!-- prettify代码高亮主题css引入 --&gt;        &lt;link href=&quot;/vendors/prettify/themes/&lt;%= theme.prettify.theme %&gt;.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;% } %&gt;    &lt;!-- 自定义css引入 --&gt;    &lt;% if (theme.customcss.enable){ %&gt;        &lt;% if (theme.customcss.csspath) { %&gt;            &lt;% for (var i in theme.customcss.csspath) { %&gt;                &lt;link href=&quot;&lt;%= theme.customcss.csspath[i] %&gt;&quot; rel=&quot;stylesheet&quot;&gt;            &lt;% } %&gt;        &lt;% } %&gt;    &lt;% } %&gt;</code></pre><ul><li>在主题下的<code>layout/_partial/import_js.ejs</code>加入以下内容：</li></ul><pre><code>&lt;!-- prettify代码高亮js引入 --&gt;&lt;% if (theme.prettify.enable){ %&gt;    &lt;script src=&quot;/vendors/prettify/prettify.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;%}%&gt;&lt;!-- Window Load--&gt;&lt;script type=&quot;text/ls-javascript&quot; id=&quot;window-load&quot;&gt;    $(window).on(&#39;load&#39;, function() {        // Post_Toc parent position fixed        $(&#39;.post-toc-wrap&#39;).parent(&#39;.mdl-menu__container&#39;).css(&#39;position&#39;, &#39;fixed&#39;);    });    $(function() {        &lt;!-- prettify代码高亮js引入 --&gt;        &lt;% if (theme.prettify.enable){ %&gt;            $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);            prettyPrint();        &lt;%}%&gt;    })&lt;/script&gt;</code></pre><ul><li>网站下的<code>_config.template.yml</code>文件修改以下内容：</li></ul><pre><code>highlight:    enable: false</code></pre><h4 id="4-最后验收成果啦"><a href="#4-最后验收成果啦" class="headerlink" title="4.最后验收成果啦"></a>4.最后验收成果啦</h4><pre><code>$ hexo clean$ hexo g$ hexo s</code></pre><p>叮！搞定！</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>iOS的应该了解的HTTPS</title>
      <link href="/2018/07/15/iOS%E4%B9%8BHTTPS/"/>
      <url>/2018/07/15/iOS%E4%B9%8BHTTPS/</url>
      
        <content type="html"><![CDATA[<pre><code>问题来源：首先为什么要接入HTTPS，对比HTTP有什么好处？并不是苹果爸爸要求我们(目前无限期延长)，而是确实有其需要的重要意义.</code></pre><h1 id="HTTPS基础"><a href="#HTTPS基础" class="headerlink" title="HTTPS基础"></a>HTTPS基础</h1><p>首先解释一下 HTTPS 这个词。 HTTPS 容易让人误解，以为他是和 HTTP 相似的协议。<br>HTTPS 全称为 HTTP Over TLS。（SSL/TLS 是一系列承前启后的加密协议族，后面统称为 TLS。）</p><h3 id="HTTPS-请求-和-HTTP-请求的异同"><a href="#HTTPS-请求-和-HTTP-请求的异同" class="headerlink" title="HTTPS 请求 和 HTTP 请求的异同"></a>HTTPS 请求 和 HTTP 请求的异同</h3><p>普通 HTTP 请求直接基于 TCP，在互联网上明文传播，而且没有任何校验，链路上的每一个节点都可以对数据包进行篡改，使用手机网络访问 HTTP 网站被插入流量球甚至广告等运营商劫持行为就是最常见的例子。而 HTTPS 请求运行在 TLS 层之上，TLS 运行在 TCP 上，TLS 有独特的握手、建立连接、数据验证机制，让运行商劫持无处下手：只要任何一个数据包被篡改，数据校验就会失败，这个请求会客户端直接抛弃，网页不会显示。当我们用 HTTP 协议来解释 TLS 层携带的内容时，这个东西就被称为 HTTPS 啦。</p><h3 id="TLS是什么"><a href="#TLS是什么" class="headerlink" title="TLS是什么"></a>TLS是什么</h3><p>TLS 中文名称为安全传输层协议，简单的来说就是在客户端与服务端之间建立一个防窃听、防篡改的可信信息传递通道。<br>关于SSL/TSL有位大佬写的非常详细有兴趣的可以深入了解一下。</p><ul><li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></li></ul><p>简单的来说，SSL/TSL通过四次握手，主要交换三个信息：</p><ol><li><strong>数字证书：</strong>该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证；</li><li><strong>三个随机数：</strong>这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的“对话密钥”。<br>首先客户端先发第一个随机数N1，然后服务器回了第二个随机数N2（这个过程同时把之前提到的证书发给客户端），这两个随机数都是明文的；而第三个随机数N3（这个随机数被称为Premaster secret），客户端用数字证书的公钥进行非对称加密，发给服务器；而服务器用只有自己知道的私钥来解密，获取第三个随机数。这样，服务端和客户端都有了三个随机数N1+N2+N3，然后两端就使用这三个随机数来生成“对话密钥”，在此之后的通信都是使用这个“对话密钥”来进行对称加密解密。因为这个过程中，服务端的私钥只用来解密第三个随机数，从来没有在网络中传输过，这样的话，只要私钥没有被泄露，那么数据就是安全的。</li><li><strong>加密通信协议</strong>：就是双方商量使用哪一种加密方式，假如两者支持的加密方式不匹配，则无法进行通信；</li></ol><p>有个常见的问题，关于随机数为什么要三个？只最后一个随机数N3不可以么？<br>这是由于SSL/TLS设计，就假设服务器不相信所有的客户端都能够提供完全随机数，假如某个客户端提供的随机数不随机的话，就大大增加了“对话密钥”被破解的风险，所以由三组随机数组成最后的随机数，保证了随机数的随机性，以此来保证每次生成的“对话密钥”安全性。</p><h1 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h1><p>//哈哈 看了就是独立可费劲莱克斯顿；积分看来；士大夫</p><pre><code>SecTrustRef trust = challenge.protectionSpace.serverTrust;    SecTrustResultType result;    SecTrustSetAnchorCertificates(trust, (__bridge CFArrayRef)self.trustedCertificates);    OSStatus status = SecTrustEvaluate(trust, &amp;result);    if (status == errSecSuccess &amp;&amp; (result == kSecTrustResultProceed || result == kSecTrustResultUnspecified)) {        NSURLCredential *cred = [NSURLCredential credentialForTrust:trust];        if (cred) {            completionHandler(NSURLSessionAuthChallengeUseCredential, cred);        } else {            completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);        }    } else {        completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);    }</code></pre><p>大家应该听说过一个词叫做<a href="https://zh.wikipedia.org/wiki/中间人攻击" target="_blank" rel="noopener">中间人攻击</a>MITM(维基)。在HTTP</p><p><a href="https://lvwenhan.com/autolayout-club/478.html" target="_blank" rel="noopener">写给 iOS 开发者看的 HTTPS 指南 </a></p><p><a href="https://lvwenhan.com/操作系统/489.html" target="_blank" rel="noopener">软件工程师需要了解的网络知识：从铜线到HTTP（五）—— HTTP 和 HTTPS</a></p><p><a href="http://oncenote.com/2014/10/21/Security-1-HTTPS/" target="_blank" rel="noopener">iOS安全系列之一：HTTPS</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
