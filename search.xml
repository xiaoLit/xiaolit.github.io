<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>iOS中的MD5摘要问题</title>
      <link href="/2018/12/28/iOSMD5/"/>
      <url>/2018/12/28/iOSMD5/</url>
      
        <content type="html"><![CDATA[<p><strong>由汉字和 \0 引发的问题</strong></p><h4 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h4><p>首先我们通常使用的MD5加密一般是iOS提供的方法。<br><code>extern unsigned char *CC_MD5(const void *data, CC_LONG len, unsigned char *md)</code><br>对于字符串使用如下</p><pre><code>- (NSString *)md5String {    const char *str = [(NSString *)self UTF8String];    unsigned char result[CC_MD5_DIGEST_LENGTH] = {0};    CC_MD5(str, (CC_LONG)strlen(str), result);    NSMutableString *ret = [NSMutableString string];    for (int i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++) {        [ret appendFormat:@&quot;%02x&quot;, result[i]];    }    return ret;}@end</code></pre><p>对于NSData使用如下</p><pre><code>- (NSString *)md5String {    const char *str = [self bytes];    unsigned char result[CC_MD5_DIGEST_LENGTH];    CC_MD5(str, (CC_LONG)self.length, result);    NSMutableString *hash = [NSMutableString string];    for (int i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++) {        [hash appendFormat:@&quot;%02X&quot;, result[i]];    }    return [hash lowercaseString];}</code></pre><h5 id="先看NSString的MD5方法"><a href="#先看NSString的MD5方法" class="headerlink" title="先看NSString的MD5方法"></a>先看NSString的MD5方法</h5><p>对于<code>NSString</code>在使用<code>CC_MD5</code>函数的时候，传入的参数是<code>strlen(str)</code>，对于<code>NSData</code>传入的参数是<code>self.length</code>，一个使用了<code>C</code>的方法，一个使用了<code>Objective-C</code>的方法。</p><p>由于<code>CC_MD5</code>是一个<code>C</code>的函数，但是在使用<code>NSString</code>的时候，<code>NSString</code>的<code>length</code>函数对字符转义进行过了处理，对于普通的字符并没有太大的区别，但是遇到中文的时候就要会出现问题。</p><pre><code>NSString *test = @&quot;我&quot;;NSLog(@&quot;%lu&quot;,(unsigned long)test.length);const char *cTest = [test UTF8String];NSLog(@&quot;%lu&quot;,strlen(cTest));</code></pre><p>前者输出了 1 后者输出了 3， 这其实是很正常的现象，因为一个中文占了3个字节，苹果对<code>length</code>进行了处理，所以，在使用<code>length</code>的时候，你获取到的汉字的长度是1，让我们在看看这个例子:</p><pre><code>NSLog(@&quot;%c&quot;,[test characterAtIndex:0]);NSLog(@&quot;%@&quot;,[test substringWithRange:NSMakeRange(0, 1)]);</code></pre><p>前者输入了乱码，后者输出了汉字“我”<br>相信很多人也都踩过这个坑，苹果文档中还特意声明<br><code>Use with rangeOfComposedCharacterSequencesForRange: to avoid breaking up character sequences</code>使用这个方法可以避免字符串被中间切断。</p><p><strong>在使用<code>NSString</code>的时候，因为<code>CC_MD5</code>是一个C函数,如果使用<code>NSString</code>提供的<code>length</code>函数被处理过后，汉字或者一些其他鬼字符的长度和<code>strlen</code>计算出来的不一样了，于是导致了这样一个隐藏问题。</strong><br>长度的编码问题可以简单<a href="https://blog.csdn.net/yaomingyang/article/details/79374209" target="_blank" rel="noopener">看下这个</a></p><h5 id="再看NSData的MD5方法"><a href="#再看NSData的MD5方法" class="headerlink" title="再看NSData的MD5方法"></a>再看NSData的MD5方法</h5><p>在 NSData 中，我们计算 CC_MD5 的时候，传入的长度是 self.length，而不再是 strlen() 计算出来的, 让我们看看下面的例子：</p><pre><code>NSString *test = @&quot;aaa\0bbb&quot;;NSLog(@&quot;%lu&quot;,(unsigned long)test.length);const char *cTest = [test UTF8String];NSLog(@&quot;%lu&quot;,strlen(cTest));</code></pre><p>前者输出了7 后者只输出了3，原因是<code>char</code>的数组在遇到’\0’的时候，认为这个字符串已经结束了，因此 将不在对<code>bbb</code>做处理了,而用<code>strlen</code>计算出来的长度只有3了。到这里 你甚至可能会和我一样疑惑，按照这样的说法，上述用<code>NSString</code>传入计算<code>MD5</code>的长度正确吗？我只能说 幸运的是在正常的<code>NSString</code>中我们不会出现<code>&#39;\0&#39;</code>这样的变态字符，除非是你自己刻意去拼出一个这样的字符.<br>但是对于<code>NSData</code>来说，会用<code>NSData</code>去计算<code>MD5</code>通常是通过文件或者音频、图片等转化过来的，因此，在<code>data</code>中什么都有可能出现，如果我没有记错的话,字符<code>&#39;\0&#39;</code>被转化成二进制应该是<code>0000 00000</code>之类的东西，如果你的<code>NSData</code>是通过压缩或者其他方式得到的,就很有可能出现一个这样的二进制<code>.....0000.....</code>(意思就是 二进制的一串中包含了一些特殊的字符,相当于转化成<code>String</code>被识别成了<code>&#39;\0&#39;</code>)，于是你再用<code>strlen</code>计算，就只会计算<code>.....0000</code>这么多了，后面的就完全忽略了，于是 这样一个潜在的<code>bug</code>就出现了。 举个例子来说：我们分别利用<code>NSString</code>和将 <code>String</code> 转化为 <code>NSData</code> 的字符串@<code>&#39;aaa&#39;</code>去计算各自的<code>MD5</code>。</p><pre><code>NSString *test = @&quot;aaa&quot;;NSLog(@&quot;%@&quot;,[test md5StringStr]);NSData *data = [test dataUsingEncoding:NSUTF8StringEncoding];NSLog(@&quot;%@&quot;,[data md5String]);</code></pre><p>计算出来的结果一样 都是 47bce5c74f589f4867dbd57e9ca9f808 </p><p>但是 当我们把字符串改成<code>@&quot;aaa\0bbb&quot;</code> (‘\0’)起到了决定性的因素</p><pre><code>NSString *test = @&quot;aaa\0bbb&quot;;</code></pre><p>在看看结果<code>NSString</code>算出来的是 47bce5c74f589f4867dbd57e9ca9f808(和上面的一样), 但是<code>NSData</code>算出来的是 ea21d344ad21e7cc63e5d4480f76dc83。<br>由此可知<code>NSString`</code>MD5<code>方法是不足以应付这种情况的，但是</code>NSData`这种就真的对吗？</p><h4 id="并不是完美的解决方法"><a href="#并不是完美的解决方法" class="headerlink" title="并不是完美的解决方法"></a>并不是完美的解决方法</h4><p>筛选了大部分方案，举一个有代表性的也是绝大部分都是这样处理的，就是将<code>NSString</code>转成<code>NSData</code>再<code>MD5</code>。<br>本文引用并验证了<a href="https://scotty-ke.github.io/2017/09/21/MD5加密的两个方法区别/" target="_blank" rel="noopener">这里的解决方法</a>和<a href="http://qiufeng.me/md5" target="_blank" rel="noopener">这个</a>，以及1000Star的<a href="https://github.com/kelp404/CocoaSecurity" target="_blank" rel="noopener">CocoaSecurity</a>都是有问题的。</p><pre><code>#import &quot;NSData+Md5.h&quot;#import &lt;CommonCrypto/CommonCrypto.h&gt;@implementation NSData (Md5)- (NSString *)md5String {    const char *str = [self bytes]; //此处打断点     unsigned char result[CC_MD5_DIGEST_LENGTH];    CC_MD5(str, (CC_LONG)self.length, result);    NSMutableString *hash = [NSMutableString string];    for (int i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++) {        [hash appendFormat:@&quot;%02X&quot;, result[i]];    }    return [hash lowercaseString];}@end//NSString 的 MD5 转化为 NSData,通过 NSData 的 MD5 计算返回结果#import &quot;NSString+Md5.h&quot;#import &quot;NSData+Md5.h&quot;@implementation NSString (Md5)- (NSString *)md5String {    NSData *data = [self dataUsingEncoding:NSUTF8StringEncoding];    return [data md5String];}@end</code></pre><p>调用<code>NSData</code>MD5时候可以在断点处发现：<br><code>const char *str = [self bytes];</code>这个str也遵循了char的特性，也就是说当<br><code>NSString *test = @&quot;aaa\0bbb&quot;;</code>在转成char的时候只会拿到<code>&#39;aaa&#39;</code>，虽然在上一个例子中两个MD5后的结果不一样，那不过是获取长度不一样了而已，<strong>仍然是有问题的</strong>。</p><h4 id="验证方法"><a href="#验证方法" class="headerlink" title="验证方法"></a>验证方法</h4><p>利用MAC终端</p><pre><code>echo -n &quot;aaa\0bbb&quot; |md5sumea21d344ad21e7cc63e5d4480f76dc83</code></pre><pre><code>echo -n &quot;aaa\0bbb&quot; | md5ea21d344ad21e7cc63e5d4480f76dc83</code></pre><p>很奇怪的和<code>NSData</code>相同，或许机制是一样的，存在某种问题，因为方法调用后内部做了什么转码等操作不得而知。<br>但是<code>aaa\0bbb</code>将此放到任意的(Google前两页的结果)MD5网站和3000Star的<a href="https://github.com/blueimp/JavaScript-MD5" target="_blank" rel="noopener">JavaScript-MD5</a>也是相同的这个结果<code>bbb28c3687f7dee991f638bbad6ef747</code>。<br>目前得到的信息只能推论出避免出现’\0’这种异常的字符，其他情况上述解决方式可以应对。</p><hr><p>题外话一：<br>有人说<code>md5sum</code>，<code>md5</code>区别在于<code>md5</code>不会默认识别’\0’和换行，我验证了一下发现并不是。</p><pre><code>➜  ~ echo  &quot;aaa\0bbb&quot; | md5sum5edba15569e2da1e986f3933cbe0f271</code></pre><pre><code>➜  ~ echo  -n &quot;aaa\0bbb&quot; | md5ea21d344ad21e7cc63e5d4480f76dc83</code></pre><pre><code>➜  ~ echo  &quot;aaa\0bbb&quot; | md55edba15569e2da1e986f3933cbe0f271</code></pre><pre><code>➜  ~ echo  -n &quot;aaa\0bbb&quot; | md5sumea21d344ad21e7cc63e5d4480f76dc83</code></pre><p>题外话二</p><pre><code>NSString *test = @&quot;aaa\0123&quot;;</code></pre><p>NSData计算出来的结果一样都是 <code>e2382c7f3e1ddc2afc53d0857a9d7572</code><br>控制台输出的是<code>448325f9203a4adbf5e7152fa6b66ad0</code><br>网页输出的是<code>03a5080b1ed003e0e21da9b8b225f099</code><br>还是不太了解什么情况。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>InjectionIII xcode10更新</title>
      <link href="/2018/11/29/InjectionIII/"/>
      <url>/2018/11/29/InjectionIII/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/johnno1962/InjectionIII" target="_blank" rel="noopener">InjectionIII - overdue Swift4 rewrite of Injection</a><br>新的安装包 <a href="http://johnholdsworth.com/InjectionIII.app.zip" target="_blank" rel="noopener">InjectionIII 1.2</a><br>新的路径调用方式，其他和原来都没有变化。</p><pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {    if DEBUG    //Swift:    // for iOS    Bundle(path: &quot;/Applications/InjectionIII.app/Contents/Resources/iOSInjection10.bundle&quot;)?.load()    //for tvOS:    Bundle(path: &quot;/Applications/InjectionIII.app/Contents/Resources/tvOSInjection10.bundle&quot;)?.load()    //Or for macOS:    Bundle(path: &quot;/Applications/InjectionIII.app/Contents/Resources/macOSInjection10.bundle&quot;)?.load()    //OC :    // for iOS    [[NSBundle bundleWithPath:@&quot;/Applications/InjectionIII.app/Contents/Resources/iOSInjection10.bundle&quot;] load];    // for tvOS    [[NSBundle bundleWithPath:@&quot;/Applications/InjectionIII.app/Contents/Resources/tvOSInjection10.bundle&quot;] load];    // for masOS    [[NSBundle bundleWithPath:@&quot;/Applications/InjectionIII.app/Contents/Resources/macOSInjection10.bundle&quot;] load];    endif}</code></pre><p>注意：新的安装包有可能不会提示移动到应用程序里，不过大家一看调用路径的配置就应该知道了，我们手动把它放进应用程序目录就搞定。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Bugly的日常</title>
      <link href="/2018/11/22/Bugly-s-Daily/"/>
      <url>/2018/11/22/Bugly-s-Daily/</url>
      
        <content type="html"><![CDATA[<h2 id="最好不要看什么其他人写的关于buglg的具体操作，就连符号表的基本提取操作之前看了其他文章都让我绕了好多弯路，直接官方文档为准。"><a href="#最好不要看什么其他人写的关于buglg的具体操作，就连符号表的基本提取操作之前看了其他文章都让我绕了好多弯路，直接官方文档为准。" class="headerlink" title="最好不要看什么其他人写的关于buglg的具体操作，就连符号表的基本提取操作之前看了其他文章都让我绕了好多弯路，直接官方文档为准。"></a>最好不要看什么其他人写的关于buglg的具体操作，就连符号表的基本提取操作之前看了其他文章都让我绕了好多弯路，直接<a href="https://bugly.qq.com/docs/user-guide/symbol-configuration-ios/?v=20181014122344" target="_blank" rel="noopener">官方文档</a>为准。</h2><p>不记得哪位大佬发的图片了，引以为向前的目标<br><img src="/images/20150415164715dc357.jpg" alt="20150415164715d"></p><pre><code>崩溃日志-[CFPrefsSearchListSource alreadylocked_copyDictionary] -[CFPrefsSearchListSource alreadylocked_copyValueForKey:] </code></pre><p>日历获取在9.x之后的系统使用 [NSCalendar currentCalendar] 会出异常。在8.0之后使用系统新API,做个分类用一下代码</p><pre><code>+ (NSCalendar *)Lit_currentCalendar {    if ([NSCalendar respondsToSelector:@selector(calendarWithIdentifier:)]) {        return [NSCalendar calendarWithIdentifier:NSCalendarIdentifierGregorian];    }    return [NSCalendar currentCalendar];}</code></pre><hr><blockquote><p>崩溃日志</p><pre><code>libGPUSupportMercury.dylib`gpus_ReturnNotPermittedKillClient</code></pre></blockquote><p>UIWebView在app进入后台时，如果没有加载渲染完就仍然在进行绘制加载，绘制<br>而苹果规定：如果尝试在后台执行OpenGL ES命令，应用程序将被终止。<br>例如<a href="https://developer.apple.com/library/archive/qa/qa1766/_index.html" target="_blank" rel="noopener">How to fix OpenGL ES application crashes when moving to the background</a></p><p>通过通知来监控app是否进入后台和前台，在进入后台的时候禁止OpenGL，在进入前台后重新加载。</p><pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(appWillResignActive:) name:UIApplicationWillResignActiveNotification object:nil];[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(appDidBecomeActive:) name:UIApplicationDidBecomeActiveNotification object:nil];</code></pre><pre><code>- (void)appWillResignActive:(NSNotification *)notification {    [self.webView stopLoading];}- (void)appDidBecomeActive:(NSNotification *)notification {    [self.webView reload];}</code></pre><pre><code>- (void)dealloc {    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationWillResignActiveNotification object:nil];    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidBecomeActiveNotification object:nil];}</code></pre><p>看到有人说iOS11修复了这个问题，但我用iOS12.1发现此问题仍在。</p><hr>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MAC翻越某知名墙体</title>
      <link href="/2018/11/21/MAC-AND-GFW/"/>
      <url>/2018/11/21/MAC-AND-GFW/</url>
      
        <content type="html"><![CDATA[<h4 id="一个酸酸倒下去，一万个酸酸分支站起来。"><a href="#一个酸酸倒下去，一万个酸酸分支站起来。" class="headerlink" title="一个酸酸倒下去，一万个酸酸分支站起来。"></a>一个酸酸倒下去，一万个酸酸分支站起来。</h4><p>不多说，用了很久了分享一下，懂的都懂，不懂你进来干啥？<br>酸酸<a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener"><code>S_S_X-NG</code></a><br>酸酸乳<a href="https://github.com/qinyuhang/ShadowsocksX-NG-R/releases" target="_blank" rel="noopener"><code>S_S_X-NG-R</code></a></p>]]></content>
      
      
      <categories>
          
          <category> 技术杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Xcode10删除的libstdc++</title>
      <link href="/2018/11/14/Xcode10-And-Libstdc/"/>
      <url>/2018/11/14/Xcode10-And-Libstdc/</url>
      
        <content type="html"><![CDATA[<p>众所周知Xcode10中删除的libstdc++库，并且手动导入的话每一次Xcode10升级会自动再次删除。需要再次手动导入。所以找个简单点的方法，虽然还是要每次导入但只需要以下文件和一行代码。</p><p><a href="https://github.com/xiaoLit/libstdc-" target="_blank" rel="noopener">需要下载的库</a><br><code>cd</code>到路径<code>libstdc</code><br><code>sudo sh install.sh</code> </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS截屏和控件截取</title>
      <link href="/2018/11/08/iOS-Screen-Shot/"/>
      <url>/2018/11/08/iOS-Screen-Shot/</url>
      
        <content type="html"><![CDATA[<h4 id="先上干货懒得看的直接跑Demo。"><a href="#先上干货懒得看的直接跑Demo。" class="headerlink" title="先上干货懒得看的直接跑Demo。"></a>先上干货懒得看的直接跑<a href="https://github.com/xiaoLit/LitShotScreen" target="_blank" rel="noopener">Demo</a>。</h4><hr><p>iOS7之后，苹果开放出一个通知：UIApplicationUserDidTakeScreenshotNotification，截屏时系统就会发出这个通知，需要你注册这个通知，就能捕捉到截屏图片。</p><pre><code> [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(getScreenShot:) name:UIApplicationUserDidTakeScreenshotNotification object:nil];</code></pre><pre><code>/** 通知回调 */- (void)getScreenShot:(NSNotification *)notification{        //获取屏幕的截图    UIImage *image = [UIView lit_screenShotImage];    //展示图片    [self showScreenShotImage:image];}</code></pre><p><strong>获取截图的方法有很多</strong></p><h4 id="方法一、-用于全屏截图最稳妥的方法目前iOS12-1也可以使用不过效率低些"><a href="#方法一、-用于全屏截图最稳妥的方法目前iOS12-1也可以使用不过效率低些" class="headerlink" title="方法一、 用于全屏截图最稳妥的方法目前iOS12.1也可以使用不过效率低些"></a><strong>方法一、</strong> 用于全屏截图最稳妥的方法目前iOS12.1也可以使用不过效率低些</h4><pre><code>/** 获取截屏 */+ (UIImage *)lit_screenShotImage {    /**     创建一个基于位图的上下文（context）,并将其设置为当前上下文(context)     @param size 参数size为新创建的位图上下文的大小。它同时是由UIGraphicsGetImageFromCurrentImageContext函数返回的图形大小     @param opaque 透明开关，如果图形完全不用透明，设置为YES以优化位图的存储，我们得到的图片背景将会是黑色，使用NO，表示透明，图片背景色正常     @param scale 缩放因子 iPhone 4是2.0，其他是1.0。虽然这里可以用[UIScreen mainScreen].scale来获取，但实际上设为0后，系统就会自动设置正确的比例了     */    UIGraphicsBeginImageContextWithOptions([UIScreen mainScreen].bounds.size, NO, 0);    //获取当前上下文    CGContextRef context = UIGraphicsGetCurrentContext();    //遍历所有窗口 用于完善处理一些多层windows显示问题    for (UIWindow *window in [[UIApplication sharedApplication] windows]) {        if ([window respondsToSelector:@selector(drawViewHierarchyInRect:afterScreenUpdates:)]) {            [window drawViewHierarchyInRect:window.bounds afterScreenUpdates:YES];        } else {            //layer是不能够直接绘制的.要用渲染的方法才能够让它绘制到上下文当中。            [window.layer renderInContext:context];        }    }    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();    UIGraphicsEndImageContext();    return image;}</code></pre><p><strong>注意：</strong>iOS 7上UIView上提供了drawViewHierarchyInRect:afterScreenUpdates:来截图，速度比renderInContext:快15倍</p><p><strong>配合剪裁图片我们可以获得更加合适截图区域</strong></p><pre><code>/** 剪裁图片  */- (UIImage *)lit_clipRect:(CGRect)rect {    //将view的转换成图片    UIGraphicsBeginImageContextWithOptions(self.frame.size, NO, 0.0);    CGContextRef context =UIGraphicsGetCurrentContext();    if ([self respondsToSelector:@selector(drawViewHierarchyInRect:afterScreenUpdates:)]) {        [self drawViewHierarchyInRect:self.bounds afterScreenUpdates:YES];    } else {        [self.layer renderInContext:context];    }    UIImage *targetImage =UIGraphicsGetImageFromCurrentImageContext();    UIGraphicsEndImageContext();    //对这个图片进行裁剪。    CGImageRef imageRef = targetImage.CGImage;    //计算截图区域时需要按比例来    CGFloat scale = [UIScreen mainScreen].scale;    //这里可以设置想要截图的区域    CGRect tempRect =  CGRectMake(rect.origin.x * scale, rect.origin.y * scale, rect.size.width * scale, rect.size.height * scale);    //是C的函数，使用CGRect的坐标都是像素    CGImageRef imageRefRect = CGImageCreateWithImageInRect(imageRef, tempRect);    UIImage *clipImage =[[UIImage alloc]initWithCGImage:imageRefRect scale:scale orientation:(UIImageOrientationUp)];    return clipImage;}</code></pre><h4 id="方法二、-适用于单个控件截图"><a href="#方法二、-适用于单个控件截图" class="headerlink" title="方法二、  适用于单个控件截图"></a><strong>方法二、</strong>  适用于单个控件截图</h4><pre><code>/** 截图控件 */- (UIView *)customSnapshotFromView:(UIView *)inputView {    UIGraphicsBeginImageContextWithOptions(inputView.frame.size, NO, 0.0);    //把控制器View的内容绘制到上下文当中.    CGContextRef context =UIGraphicsGetCurrentContext();    //layer是不能够直接绘制的.要用渲染的方法才能够让它绘制到上下文当中。UIGraphicsGetCurrentContext()    [inputView.layer renderInContext:context];    //从上下文当中生成一张图片    UIImage*targetImage =UIGraphicsGetImageFromCurrentImageContext();    UIGraphicsEndImageContext();    UIImageView*imageView = [[UIImageView alloc]initWithImage:targetImage];    imageView.frame= inputView.frame;    return imageView;}</code></pre><h4 id="方法三、-iOS7就支持非常便捷的截图方法snapshotViewAfterScreenUpdates"><a href="#方法三、-iOS7就支持非常便捷的截图方法snapshotViewAfterScreenUpdates" class="headerlink" title="方法三、  iOS7就支持非常便捷的截图方法snapshotViewAfterScreenUpdates"></a><strong>方法三、</strong>  iOS7就支持非常便捷的截图方法snapshotViewAfterScreenUpdates</h4><pre><code>- (UIView *)customSnapshotFromView:(UIView *)inputView {    //afterUpdates参数表示是否在所有效果应用在视图上了以后再获取快照。    //例如，如果该参数为NO，则立马获取该视图现在状态的快照，反之，以下代码只能得到一个空白快照：    UIView *snapshot = [inputView snapshotViewAfterScreenUpdates:YES];    snapshot.layer.masksToBounds = YES;    return snapshot;}</code></pre><p>但是据说iOS10之后就不好使了，我用的iOS12测试发现和iOS9模拟器都无法使用，所以现在使用的话此方法有待考察。</p><hr><p>有可能有特殊的情况,会要求横屏等其他方向截屏变成正常竖屏样式展示，将截屏的图片进行仿射变换就可以了。Demo也有相关代码。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HEXO+GitHub搭建博客的一些心得</title>
      <link href="/2018/10/09/Material/"/>
      <url>/2018/10/09/Material/</url>
      
        <content type="html"><![CDATA[<p><a href="https://material.io/tools/icons/?search=link&amp;style=baseline" target="_blank" rel="noopener"><code>Material Design</code>图片库</a><br><a href="https://github.com/Vultur/hexo-theme-material" target="_blank" rel="noopener"><code>hexo-theme-material</code>配置文件详细描述</a><br>我使用的<code>HEXO+ GitHub page</code>的形式搭建自己的博客，<a href="https://hanyx1992.github.io/2018/05/02/helloworld/" target="_blank" rel="noopener">参考大佬</a>。<br>搭建好了采用的hexo-theme-material主题，然后还需要配置一些我们常用的功能。</p><h2 id="material-1-5-5和1-5-6版本使用过程中出现报错"><a href="#material-1-5-5和1-5-6版本使用过程中出现报错" class="headerlink" title="material-1.5.5和1.5.6版本使用过程中出现报错"></a>material-1.5.5和1.5.6版本使用过程中出现报错</h2><p>解决方案<a href="https://github.com/viosey/hexo-theme-material/issues/686" target="_blank" rel="noopener">issue#686</a>。<br>修改layout/_widget/dnsprefetch.ejs文件。修改内容如下：</p><pre><code>&lt;% } else if(theme.comment.use.startsWith(&quot;disqus&quot;)) { %&gt;修改为&lt;% } else if(theme.comment.use &amp;&amp; theme.comment.use.startsWith(&quot;disqus&quot;)) { %&gt;</code></pre><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>综合各种因素，七牛云足以。<br>纯界面操作这位大佬<a href="https://sspai.com/post/43598" target="_blank" rel="noopener">Jackier</a>图片贴的非常详细，看了就懂。</p><h2 id="独立页面"><a href="#独立页面" class="headerlink" title="独立页面"></a>独立页面</h2><h3 id="添加任意侧栏功能"><a href="#添加任意侧栏功能" class="headerlink" title="添加任意侧栏功能"></a>添加任意侧栏功能</h3><pre><code>pages:     title:                               #可以填写任意标题        link: &quot;http://example.com&quot;       #点击跳转的链接        icon: link                       #图标 可以到Material Design图片图找        divider: false                   #分割线</code></pre><h3 id="友情链接页面"><a href="#友情链接页面" class="headerlink" title="友情链接页面"></a>友情链接页面</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul><li>在<code>hexo</code>目录下的<code>source</code>文件夹内创建一个名为<code>links</code>（只是建议，可根据自己喜好修改）的文件夹。</li><li>然后在文件内创建一个名为<code>index.md</code>的<code>Markdown</code>文件。</li><li>在<code>index.md</code>文件内写入如下内容即可。</li></ul><pre><code>---title: linksdate:layout: links---</code></pre><p><code>title</code> 可修改，<code>layout</code> 不可修改。</p><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><ul><li>同样在在<code>hexo</code>目录下的<code>source</code>文件夹内创建一个名为<code>_data</code>（禁止改名）的文件夹。</li><li>然后在文件内创建一个名为 <code>links.yml</code> 的文件。</li><li>单个友情链接的格式为：</li></ul><pre><code>    Name:    link: http://example.com    avatar: http://example.com/avatar.png    descr: &quot;这是一个描述&quot;</code></pre><ul><li>添加多个友情链接，只需要根据上面的格式重复填写即可。</li><li>将 <code>Name</code> 改为友情链接的名字，例如 Jack。</li><li><code>http://example.com</code>为友情链接的地址。</li><li><code>http://example.com/avatar.png</code> 为友情链接的头像。</li><li>这是一个描述 为友情链接描述。</li></ul><h4 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h4><p>在主题<code>_config.yml</code>文件下加入</p><pre><code>pages:    友情链接: &quot;/links/&quot;</code></pre><h3 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><p>在 <code>hexo</code> 目录下的 <code>source</code> 文件夹内创建一个名为 <code>timeline</code>（只是建议，可根据自己喜好修改）的文件夹。<br>然后在文件内创建一个名为 <code>index.md</code> 的 <code>Markdown</code> 文件。<br>在 index.md 文件内写入如下内容即可。</p><pre><code>---title: timelinedate:layout: timeline---</code></pre><p> <code>title</code> 可修改，<code>layout</code> 不可修改。</p><h4 id="开启-1"><a href="#开启-1" class="headerlink" title="开启"></a>开启</h4><pre><code>pages:   时间轴:        link: &quot;/timeline&quot;        icon: timeline        divider: false</code></pre><h2 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h2><p>material本身也集成了很多其他主流的评论系统大家可以自行选择。但我综合各种因素，例如使用是否方便，是否需要备案，是否需要翻越某个神秘的墙体，选择了<code>gitalk</code>。</p><h3 id="注册OAuth-Application"><a href="#注册OAuth-Application" class="headerlink" title="注册OAuth Application"></a>注册<code>OAuth Application</code></h3><p><a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">点击此处</a> 来注册一个新的 <code>OAuth Application</code>。注意最后一个<code>Authorization callback URL</code>要填写自己博客的<code>url</code>。注册成功后得到一个<code>Client ID</code>和<code>Client Secret</code>。</p><p>###配置参数<br>在<code>material</code>的<code>_config.yml</code>中找到<code>Comment Systems</code>相关配置。</p><pre><code># Comment Systemscomment:    use: &quot;gitalk&quot;    gitalk_repo: gitalk            #这里是因为我在第一步中注册 OAuth Application 的 repo 名字叫做 gitalk    gitalk_owner: xiaoLit          #这里当然是 github 用户名了    gitalk_client_id: ******       #这里是第一步的Client ID    gitalk_client_secret: ******   #这里是第一步的Client Secret</code></pre><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>配置好后部署就可以了。</p><p>注意: 有可能会出现<code>Error: Validation Failed</code>错误。这是由于创建<code>gitalk</code>时会将当前<code>post</code>的<code>url</code>作为<code>label</code>创建一个<code>issue</code>，而<code>issue</code>的<code>label</code>长度最大只支持50个字符，如果文章标题有过多中文或长度太长，都会产生这个问题。<br>解决方案：在该目录~/themes/material/layout/_widget/comment/gitalk/main.ejs</p><pre><code>&lt;script&gt;    var gitalk = new Gitalk({            clientID: &#39;&lt;%= theme.comment.gitalk_client_id %&gt;&#39;,            clientSecret: &#39;&lt;%= theme.comment.gitalk_client_secret %&gt;&#39;,            repo: &#39;&lt;%= theme.comment.gitalk_repo %&gt;&#39;,            owner: &#39;&lt;%= theme.comment.gitalk_owner %&gt;&#39;,            admin: [&#39;&lt;%= theme.comment.gitalk_owner %&gt;&#39;],            // facebook-like distraction free mode            distractionFreeMode: false,            id: &#39;&lt;%=  page.title.substr(0,48) %&gt;&#39;  //额外加入了这句        })   gitalk.render(&#39;gitalk-container&#39;)&lt;/script&gt;</code></pre><p><a href="https://github.com/viosey/hexo-theme-material/pull/617/commits/a6863aa930599ddd6f6e69bbdc66fdfc89a4deb3" target="_blank" rel="noopener">#617</a></p><p>##topPost<br>使用该插件可以将指定文章置顶。<br> <code>npm install hexo-helper-post-top --save</code><br>使用在您需要置顶文章的 front-matter 中，添加 top: true 即可置顶。</p><h2 id="使用CDN加速"><a href="#使用CDN加速" class="headerlink" title="使用CDN加速"></a>使用CDN加速</h2><blockquote><p>目前没有必要使用</p></blockquote><p>修改文件:博客/themes/material/_config.yml<br>根据自己使用不同版本去寻找相应的链接，<a href="https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material/source/" target="_blank" rel="noopener">查看对应版本链接</a>。</p><pre><code>materialcdn: https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@1.5.6/source</code></pre><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>Material 主题内置了 google swiftype local 三种搜索系统。<br>需要在文章内搜索的话使用本地搜索，需要安装<code>hexo-generator-search</code>插件。</p><h3 id="安装hexo-generator-search"><a href="#安装hexo-generator-search" class="headerlink" title="安装hexo-generator-search"></a>安装<code>hexo-generator-search</code></h3><p><code>$ npm install hexo-generator-search --save</code></p><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><ul><li>修改文件:博客/themes/material/_config.yml</li></ul><pre><code>search:    use: local #此处使用了本地搜索</code></pre><ul><li>修改文件:博客/_config.yml</li></ul><pre><code>search:  path: search.xml  field: post</code></pre><h2 id="新版prettify自动折行替换为不折行并添加滚动条"><a href="#新版prettify自动折行替换为不折行并添加滚动条" class="headerlink" title="新版prettify自动折行替换为不折行并添加滚动条"></a>新版prettify自动折行替换为不折行并添加滚动条</h2><h3 id="解决方案issues-616"><a href="#解决方案issues-616" class="headerlink" title="解决方案issues#616"></a>解决方案<a href="https://github.com/viosey/hexo-theme-material/issues/616" target="_blank" rel="noopener">issues#616</a></h3><ul><li>把<code>source/css/prettify.css</code>直接替换为</li></ul><pre><code>@charset &quot;UTF-8&quot;;/* for color-themes-for-google-code-prettify *//* Automatically add a scroll bar instead of a newline */pre{    white-space: pre;}#post-content .prettyprint{    padding: 1.2em;    border-radius: 0;}#post-content ol,#post-content ul{    padding-left: 32px;    font-size: 1rem;    margin: 0;    overflow: initial;}#post-content pre code, #post-content pre tt {    padding-right: 2em;}#post-content .prettyprint li.L0, #post-content .prettyprint li.L1,#post-content .prettyprint li.L2, #post-content .prettyprint li.L3,#post-content .prettyprint li.L4, #post-content .prettyprint li.L5,#post-content .prettyprint li.L6, #post-content .prettyprint li.L7,#post-content .prettyprint li.L8, #post-content .prettyprint li.L9 {    padding-left: 0.5em;}</code></pre><ul><li><code>source/css/prettify.min.css</code>直接替换为：</li></ul><pre><code>pre{white-space:pre}#post-content .prettyprint{padding:1.2em;border-radius:0}#post-content ol,#post-content ul{padding-left:32px;font-size:1rem;margin:0;overflow:initial}#post-content pre code,#post-content pre tt{padding-right:2em}#post-content .prettyprint li.L0,#post-content .prettyprint li.L1,#post-content .prettyprint li.L2,#post-content .prettyprint li.L3,#post-content .prettyprint li.L4,#post-content .prettyprint li.L5,#post-content .prettyprint li.L6,#post-content .prettyprint li.L7,#post-content .prettyprint li.L8,#post-content .prettyprint li.L9{padding-left:.5em}</code></pre><h2 id="去代码掉行号"><a href="#去代码掉行号" class="headerlink" title="去代码掉行号"></a>去代码掉行号</h2><p>看代码还是一行舒服<br>默认hanabi是支持的，只需要</p><pre><code>hanabi:    enable: true    line_number: true</code></pre><p>可是material-1.5.5和1.5.6版本使用prettify不支持去掉行号，那么就只有暴力处理了。<br>修改<code>themes/material/layout/_partial</code> 下的文件<code>import_js.ejs</code></p><pre><code>$(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);替换为：$(&#39;pre&#39;).addClass(&#39;prettyprint&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);</code></pre><h2 id="使用-CDN加速"><a href="#使用-CDN加速" class="headerlink" title="使用 CDN加速"></a>使用 CDN加速</h2><p>定位到 主题配置文件 进行配置。<br>MaterialCDN<br>现在你可以使用 CDN 来加速 Material 主题引用的静态文件，只需要在 materialcdn 中填入你的 CDN 的 URL 路径即可。默认为空、从网站源站加载。</p><p>注意！填入的 URL 末尾不需要带 / ！<br>例如，您可以这么配置：</p><p>vendors:<br>    materialcdn:  <a href="https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/viosey/hexo-theme-material@latest/source</a><br>您可以使用由 jsDelivr 提供的公共 CDN 加速您的博客。</p><h2 id="安装prettify的正确姿势"><a href="#安装prettify的正确姿势" class="headerlink" title="安装prettify的正确姿势"></a>安装prettify的正确姿势</h2><p><strong>更新</strong><br>分割线以下安装步骤为老版的内容，1.5.5和1.5.6版本无需再用此方法。</p><ul><li>直接改主题下<code>_config.yml</code>文件即可</li></ul><pre><code>prettify:    enable: true    theme: &quot;vibrant-ink&quot;</code></pre><p>集成了大部分prettify,可在目录<code>themes/material/source/css/prettify</code>查看具体名字，觉得挨个尝试麻烦的话可以直接到<a href="https://jmblog.github.io/color-themes-for-google-code-prettify/" target="_blank" rel="noopener">这里</a>看效果然后填写目录下的相应主题名字。</p><hr><hr><p>开始看了 <a href="https://hanyx1992.github.io/2018/05/02/helloworld/" target="_blank" rel="noopener">@旭丶Joy</a> 大佬的文章设置prettify发现代码块滚动条异常。于是去爬论坛，发现这个问题在<a href="https://github.com/viosey/hexo-theme-material/issues/383" target="_blank" rel="noopener">issue#383</a>中解决，并且在<a href="https://github.com/viosey/hexo-theme-material/issues/616" target="_blank" rel="noopener">issue#616</a>优化过，也就是新版本是包含的。所以猜想应该该主题支持的方式有可能不同，于是在<a href="https://github.com/viosey/hexo-theme-material/pull/395" target="_blank" rel="noopener">issue#395</a>找到了该姿势。</p><h3 id="安装code-prettify"><a href="#安装code-prettify" class="headerlink" title="安装code-prettify"></a>安装code-prettify</h3><ul><li><code>git clone https://github.com/google/code-prettify.git</code></li><li>将src重命名为prettify，然后目录prettify拷贝至你的 hexo 博客的 source/vendors/下, vendors是新建的目录</li></ul><h3 id="安装color-themes-for-google-code-prettify"><a href="#安装color-themes-for-google-code-prettify" class="headerlink" title="安装color-themes-for-google-code-prettify"></a>安装color-themes-for-google-code-prettify</h3><pre><code>$ cd yourproject$ npm i color-themes-for-google-code-prettify -S$ cd node_modules/color-themes-for-google-code-prettify/dist$ cp -r themes ../../../themes/material/source/vendors/prettify/</code></pre><p>其实就是安装<code>color-themes-for-google-code-prettify</code>, 将dist/themes拷贝到<code>themes/material/source/vendors/prettify/</code>下</p><h3 id="prettify用法"><a href="#prettify用法" class="headerlink" title="prettify用法"></a>prettify用法</h3><ul><li>主题下的<code>_config.template.yml</code>追加以下内容：</li></ul><pre><code>prettify:    enable: true   # if true, customcss.enable must be true    theme: &quot;vibrant-ink&quot; # default value: &quot;vibrant-ink&quot;   # &quot;theme-name without .css&quot;# custom csscustomcss:    enable: true    csspath: [  # css file path        &quot;/css/custom-prettify.min.css&quot;    ]</code></pre><ul><li>在主题下的<code>layout/_partial/head.ejs</code>追加下面内容：</li></ul><pre><code>&lt;% if (theme.prettify.enable){ %&gt;        &lt;!-- prettify代码高亮主题css引入 --&gt;        &lt;link href=&quot;/vendors/prettify/themes/&lt;%= theme.prettify.theme %&gt;.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;% } %&gt;    &lt;!-- 自定义css引入 --&gt;    &lt;% if (theme.customcss.enable){ %&gt;        &lt;% if (theme.customcss.csspath) { %&gt;            &lt;% for (var i in theme.customcss.csspath) { %&gt;                &lt;link href=&quot;&lt;%= theme.customcss.csspath[i] %&gt;&quot; rel=&quot;stylesheet&quot;&gt;            &lt;% } %&gt;        &lt;% } %&gt;    &lt;% } %&gt;</code></pre><ul><li>在主题下的<code>layout/_partial/import_js.ejs</code>加入以下内容：</li></ul><pre><code>&lt;!-- prettify代码高亮js引入 --&gt;&lt;% if (theme.prettify.enable){ %&gt;    &lt;script src=&quot;/vendors/prettify/prettify.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;%}%&gt;&lt;!-- Window Load--&gt;&lt;script type=&quot;text/ls-javascript&quot; id=&quot;window-load&quot;&gt;    $(window).on(&#39;load&#39;, function() {        // Post_Toc parent position fixed        $(&#39;.post-toc-wrap&#39;).parent(&#39;.mdl-menu__container&#39;).css(&#39;position&#39;, &#39;fixed&#39;);    });    $(function() {        &lt;!-- prettify代码高亮js引入 --&gt;        &lt;% if (theme.prettify.enable){ %&gt;            $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);            prettyPrint();        &lt;%}%&gt;    })&lt;/script&gt;</code></pre><ul><li>网站下的<code>_config.template.yml</code>文件修改以下内容：</li></ul><pre><code>highlight:    enable: false</code></pre><h3 id="最后验收成果啦"><a href="#最后验收成果啦" class="headerlink" title="最后验收成果啦"></a>最后验收成果啦</h3><pre><code>$ hexo clean$ hexo g$ hexo s</code></pre><p>叮！搞定！</p>]]></content>
      
      
      <categories>
          
          <category> 技术杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS的应该了解的HTTPS</title>
      <link href="/2018/07/15/iOS-s-HTTPS/"/>
      <url>/2018/07/15/iOS-s-HTTPS/</url>
      
        <content type="html"><![CDATA[<pre><code>问题来源：首先为什么要接入HTTPS，对比HTTP有什么好处？并不是苹果爸爸要求我们(目前无限期延长)，而是确实有其需要的重要意义.</code></pre><h1 id="HTTPS基础"><a href="#HTTPS基础" class="headerlink" title="HTTPS基础"></a>HTTPS基础</h1><p>首先解释一下 HTTPS 这个词。 HTTPS 容易让人误解，以为他是和 HTTP 相似的协议。<br>HTTPS 全称为 HTTP Over TLS。（SSL/TLS 是一系列承前启后的加密协议族，后面统称为 TLS。）</p><h3 id="HTTPS-请求-和-HTTP-请求的异同"><a href="#HTTPS-请求-和-HTTP-请求的异同" class="headerlink" title="HTTPS 请求 和 HTTP 请求的异同"></a>HTTPS 请求 和 HTTP 请求的异同</h3><p>普通 HTTP 请求直接基于 TCP，在互联网上明文传播，而且没有任何校验，链路上的每一个节点都可以对数据包进行篡改，使用手机网络访问 HTTP 网站被插入流量球甚至广告等运营商劫持行为就是最常见的例子。而 HTTPS 请求运行在 TLS 层之上，TLS 运行在 TCP 上，TLS 有独特的握手、建立连接、数据验证机制，让运行商劫持无处下手：只要任何一个数据包被篡改，数据校验就会失败，这个请求会客户端直接抛弃，网页不会显示。当我们用 HTTP 协议来解释 TLS 层携带的内容时，这个东西就被称为 HTTPS 啦。</p><h3 id="TLS是什么"><a href="#TLS是什么" class="headerlink" title="TLS是什么"></a>TLS是什么</h3><p>TLS 中文名称为安全传输层协议，简单的来说就是在客户端与服务端之间建立一个防窃听、防篡改的可信信息传递通道。<br>关于SSL/TSL有位大佬写的非常详细有兴趣的可以深入了解一下。</p><ul><li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></li></ul><p>简单的来说，SSL/TSL通过四次握手，主要交换三个信息：</p><ol><li><strong>数字证书：</strong>该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证；</li><li><strong>三个随机数：</strong>这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的“对话密钥”。<br>首先客户端先发第一个随机数N1，然后服务器回了第二个随机数N2（这个过程同时把之前提到的证书发给客户端），这两个随机数都是明文的；而第三个随机数N3（这个随机数被称为Premaster secret），客户端用数字证书的公钥进行非对称加密，发给服务器；而服务器用只有自己知道的私钥来解密，获取第三个随机数。这样，服务端和客户端都有了三个随机数N1+N2+N3，然后两端就使用这三个随机数来生成“对话密钥”，在此之后的通信都是使用这个“对话密钥”来进行对称加密解密。因为这个过程中，服务端的私钥只用来解密第三个随机数，从来没有在网络中传输过，这样的话，只要私钥没有被泄露，那么数据就是安全的。</li><li><strong>加密通信协议</strong>：就是双方商量使用哪一种加密方式，假如两者支持的加密方式不匹配，则无法进行通信；</li></ol><p>有个常见的问题，关于随机数为什么要三个？只最后一个随机数N3不可以么？<br>这是由于SSL/TLS设计，就假设服务器不相信所有的客户端都能够提供完全随机数，假如某个客户端提供的随机数不随机的话，就大大增加了“对话密钥”被破解的风险，所以由三组随机数组成最后的随机数，保证了随机数的随机性，以此来保证每次生成的“对话密钥”安全性。</p><h1 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h1><p>//哈哈 看了就是独立可费劲莱克斯顿；积分看来；士大夫</p><pre><code>SecTrustRef trust = challenge.protectionSpace.serverTrust;    SecTrustResultType result;    SecTrustSetAnchorCertificates(trust, (__bridge CFArrayRef)self.trustedCertificates);    OSStatus status = SecTrustEvaluate(trust, &amp;result);    if (status == errSecSuccess &amp;&amp; (result == kSecTrustResultProceed || result == kSecTrustResultUnspecified)) {        NSURLCredential *cred = [NSURLCredential credentialForTrust:trust];        if (cred) {            completionHandler(NSURLSessionAuthChallengeUseCredential, cred);        } else {            completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);        }    } else {        completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);    }</code></pre><p>大家应该听说过一个词叫做<a href="https://zh.wikipedia.org/wiki/中间人攻击" target="_blank" rel="noopener">中间人攻击</a>MITM(维基)。在HTTP</p><p><a href="https://lvwenhan.com/autolayout-club/478.html" target="_blank" rel="noopener">写给 iOS 开发者看的 HTTPS 指南 </a></p><p><a href="https://lvwenhan.com/操作系统/489.html" target="_blank" rel="noopener">软件工程师需要了解的网络知识：从铜线到HTTP（五）—— HTTP 和 HTTPS</a></p><p><a href="http://oncenote.com/2014/10/21/Security-1-HTTPS/" target="_blank" rel="noopener">iOS安全系列之一：HTTPS</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
