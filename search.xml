<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>使用hexo-theme-material主题遇到的一些问题</title>
      <link href="/2018/07/15/Material/"/>
      <url>/2018/07/15/Material/</url>
      
        <content type="html"><![CDATA[<h2 id="material-1-5-5和1-5-6版本使用过程中出现报错。"><a href="#material-1-5-5和1-5-6版本使用过程中出现报错。" class="headerlink" title="material-1.5.5和1.5.6版本使用过程中出现报错。"></a>material-1.5.5和1.5.6版本使用过程中出现报错。</h2><p>解决方案<a href="https://github.com/viosey/hexo-theme-material/issues/686" target="_blank" rel="noopener">issue#686</a>。<br>修改layout/_widget/dnsprefetch.ejs文件。修改内容如下：</p><pre><code>&lt;% } else if(theme.comment.use.startsWith(&quot;disqus&quot;)) { %&gt;修改为&lt;% } else if(theme.comment.use &amp;&amp; theme.comment.use.startsWith(&quot;disqus&quot;)) { %&gt;</code></pre><h2 id="博客本地搜索功能"><a href="#博客本地搜索功能" class="headerlink" title="博客本地搜索功能"></a>博客本地搜索功能</h2><p>安装<code>hexo-generator-search</code><br><code>$ npm install hexo-generator-search --save</code><br>修改文件:博客/themes/material/_config.yml</p><pre><code>search:    use: local</code></pre><p>修改文件:博客/_config.yml</p><pre><code>search:  path: search.xml  field: post</code></pre><h2 id="新版prettify自动折行替换为不折行并添加滚动条"><a href="#新版prettify自动折行替换为不折行并添加滚动条" class="headerlink" title="新版prettify自动折行替换为不折行并添加滚动条"></a>新版prettify自动折行替换为不折行并添加滚动条</h2><p>解决方案<a href="https://github.com/viosey/hexo-theme-material/issues/616" target="_blank" rel="noopener">issues#616</a><br>把<code>source/css/prettify.css</code>直接替换为</p><pre><code>@charset &quot;UTF-8&quot;;/* for color-themes-for-google-code-prettify *//* Automatically add a scroll bar instead of a newline */pre{    white-space: pre;}#post-content .prettyprint{    padding: 1.2em;    border-radius: 0;}#post-content ol,#post-content ul{    padding-left: 32px;    font-size: 1rem;    margin: 0;    overflow: initial;}#post-content pre code, #post-content pre tt {    padding-right: 2em;}#post-content .prettyprint li.L0, #post-content .prettyprint li.L1,#post-content .prettyprint li.L2, #post-content .prettyprint li.L3,#post-content .prettyprint li.L4, #post-content .prettyprint li.L5,#post-content .prettyprint li.L6, #post-content .prettyprint li.L7,#post-content .prettyprint li.L8, #post-content .prettyprint li.L9 {    padding-left: 0.5em;}</code></pre><p><code>source/css/prettify.min.css</code>直接替换为：</p><pre><code>pre{white-space:pre}#post-content .prettyprint{padding:1.2em;border-radius:0}#post-content ol,#post-content ul{padding-left:32px;font-size:1rem;margin:0;overflow:initial}#post-content pre code,#post-content pre tt{padding-right:2em}#post-content .prettyprint li.L0,#post-content .prettyprint li.L1,#post-content .prettyprint li.L2,#post-content .prettyprint li.L3,#post-content .prettyprint li.L4,#post-content .prettyprint li.L5,#post-content .prettyprint li.L6,#post-content .prettyprint li.L7,#post-content .prettyprint li.L8,#post-content .prettyprint li.L9{padding-left:.5em}</code></pre><h2 id="去掉行号"><a href="#去掉行号" class="headerlink" title="去掉行号"></a>去掉行号</h2><p>默认hanabi是支持的，只需要</p><pre><code>hanabi:    enable: true    line_number: true</code></pre><p>可是material-1.5.5和1.5.6版本使用prettify不支持去掉行号，那么就只有暴力处理了。<br>修改<code>themes/material/layout/_partial</code> 下的文件<code>import_js.ejs</code></p><pre><code>$(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);替换为：$(&#39;pre&#39;).addClass(&#39;prettyprint&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);</code></pre><h2 id="安装prettify的正确姿势"><a href="#安装prettify的正确姿势" class="headerlink" title="安装prettify的正确姿势"></a>安装prettify的正确姿势</h2><h6 id="更新"><a href="#更新" class="headerlink" title="更新"></a><strong>更新</strong></h6><p>分割线以下安装步骤为老版的内容，1.5.5和1.5.6版本无需再用此方法。<br>直接改主题下<code>_config.yml</code>文件即可</p><pre><code>prettify:    enable: true    theme: &quot;vibrant-ink&quot;</code></pre><p>集成了大部分prettify,可在目录<code>themes/material/source/css/prettify</code>查看具体名字，觉得麻烦可以直接到<a href="https://jmblog.github.io/color-themes-for-google-code-prettify/" target="_blank" rel="noopener">这里</a>看效果然后填写。</p><hr><p>开始看了 <a href="https://hanyx1992.github.io/2018/05/02/helloworld/" target="_blank" rel="noopener">@韩元旭</a> 大佬的文章设置prettify发现代码块滚动条异常。于是去爬论坛，发现这个问题在<a href="https://github.com/viosey/hexo-theme-material/issues/383" target="_blank" rel="noopener">issue#383</a>中解决，并且在<a href="https://github.com/viosey/hexo-theme-material/issues/616" target="_blank" rel="noopener">issue#616</a>优化过，也就是新版本是包含的。所以猜想应该该主题支持的方式有可能不同，于是在<a href="https://github.com/viosey/hexo-theme-material/pull/395" target="_blank" rel="noopener">issue#395</a>找到了该姿势。</p><h4 id="1-安装code-prettify"><a href="#1-安装code-prettify" class="headerlink" title="1.安装code-prettify"></a>1.安装code-prettify</h4><ul><li><code>git clone https://github.com/google/code-prettify.git</code></li><li>将src重命名为prettify，然后目录prettify拷贝至你的 hexo 博客的 source/vendors/下, vendors是新建的目录</li></ul><h4 id="2-安装color-themes-for-google-code-prettify"><a href="#2-安装color-themes-for-google-code-prettify" class="headerlink" title="2. 安装color-themes-for-google-code-prettify"></a>2. 安装color-themes-for-google-code-prettify</h4><pre><code>$ cd yourproject$ npm i color-themes-for-google-code-prettify -S$ cd node_modules/color-themes-for-google-code-prettify/dist$ cp -r themes ../../../themes/material/source/vendors/prettify/</code></pre><p>其实就是安装<code>color-themes-for-google-code-prettify</code>, 将dist/themes拷贝到<code>themes/material/source/vendors/prettify/</code>下</p><h4 id="3-prettify用法"><a href="#3-prettify用法" class="headerlink" title="3. prettify用法"></a>3. prettify用法</h4><ul><li>主题下的<code>_config.template.yml</code>追加以下内容：</li></ul><pre><code>prettify:    enable: true   # if true, customcss.enable must be true    theme: &quot;vibrant-ink&quot; # default value: &quot;vibrant-ink&quot;   # &quot;theme-name without .css&quot;# custom csscustomcss:    enable: true    csspath: [  # css file path        &quot;/css/custom-prettify.min.css&quot;    ]</code></pre><ul><li>在主题下的<code>layout/_partial/head.ejs</code>追加下面内容：</li></ul><pre><code>&lt;% if (theme.prettify.enable){ %&gt;        &lt;!-- prettify代码高亮主题css引入 --&gt;        &lt;link href=&quot;/vendors/prettify/themes/&lt;%= theme.prettify.theme %&gt;.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;% } %&gt;    &lt;!-- 自定义css引入 --&gt;    &lt;% if (theme.customcss.enable){ %&gt;        &lt;% if (theme.customcss.csspath) { %&gt;            &lt;% for (var i in theme.customcss.csspath) { %&gt;                &lt;link href=&quot;&lt;%= theme.customcss.csspath[i] %&gt;&quot; rel=&quot;stylesheet&quot;&gt;            &lt;% } %&gt;        &lt;% } %&gt;    &lt;% } %&gt;</code></pre><ul><li>在主题下的<code>layout/_partial/import_js.ejs</code>加入以下内容：</li></ul><pre><code>&lt;!-- prettify代码高亮js引入 --&gt;&lt;% if (theme.prettify.enable){ %&gt;    &lt;script src=&quot;/vendors/prettify/prettify.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;%}%&gt;&lt;!-- Window Load--&gt;&lt;script type=&quot;text/ls-javascript&quot; id=&quot;window-load&quot;&gt;    $(window).on(&#39;load&#39;, function() {        // Post_Toc parent position fixed        $(&#39;.post-toc-wrap&#39;).parent(&#39;.mdl-menu__container&#39;).css(&#39;position&#39;, &#39;fixed&#39;);    });    $(function() {        &lt;!-- prettify代码高亮js引入 --&gt;        &lt;% if (theme.prettify.enable){ %&gt;            $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);            prettyPrint();        &lt;%}%&gt;    })&lt;/script&gt;</code></pre><ul><li>网站下的<code>_config.template.yml</code>文件修改以下内容：</li></ul><pre><code>highlight:    enable: false</code></pre><h4 id="4-最后验收成果啦"><a href="#4-最后验收成果啦" class="headerlink" title="4.最后验收成果啦"></a>4.最后验收成果啦</h4><pre><code>$ hexo clean$ hexo g$ hexo s</code></pre><p>叮！搞定！</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>iOS的应该了解的HTTPS</title>
      <link href="/2018/07/15/iOS%E4%B9%8BHTTPS/"/>
      <url>/2018/07/15/iOS%E4%B9%8BHTTPS/</url>
      
        <content type="html"><![CDATA[<pre><code>问题来源：首先为什么要接入HTTPS，对比HTTP有什么好处？并不是苹果爸爸要求我们(目前无限期延长)，而是确实有其需要的重要意义.</code></pre><h1 id="HTTPS基础"><a href="#HTTPS基础" class="headerlink" title="HTTPS基础"></a>HTTPS基础</h1><p>首先解释一下 HTTPS 这个词。 HTTPS 容易让人误解，以为他是和 HTTP 相似的协议。<br>HTTPS 全称为 HTTP Over TLS。（SSL/TLS 是一系列承前启后的加密协议族，后面统称为 TLS。）</p><h3 id="HTTPS-请求-和-HTTP-请求的异同"><a href="#HTTPS-请求-和-HTTP-请求的异同" class="headerlink" title="HTTPS 请求 和 HTTP 请求的异同"></a>HTTPS 请求 和 HTTP 请求的异同</h3><p>普通 HTTP 请求直接基于 TCP，在互联网上明文传播，而且没有任何校验，链路上的每一个节点都可以对数据包进行篡改，使用手机网络访问 HTTP 网站被插入流量球甚至广告等运营商劫持行为就是最常见的例子。而 HTTPS 请求运行在 TLS 层之上，TLS 运行在 TCP 上，TLS 有独特的握手、建立连接、数据验证机制，让运行商劫持无处下手：只要任何一个数据包被篡改，数据校验就会失败，这个请求会客户端直接抛弃，网页不会显示。当我们用 HTTP 协议来解释 TLS 层携带的内容时，这个东西就被称为 HTTPS 啦。</p><h3 id="TLS是什么"><a href="#TLS是什么" class="headerlink" title="TLS是什么"></a>TLS是什么</h3><p>TLS 中文名称为安全传输层协议，简单的来说就是在客户端与服务端之间建立一个防窃听、防篡改的可信信息传递通道。<br>关于SSL/TSL有位大佬写的非常详细有兴趣的可以深入了解一下。</p><ul><li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></li></ul><p>简单的来说，SSL/TSL通过四次握手，主要交换三个信息：</p><ol><li><strong>数字证书：</strong>该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证；</li><li><strong>三个随机数：</strong>这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的“对话密钥”。<br>首先客户端先发第一个随机数N1，然后服务器回了第二个随机数N2（这个过程同时把之前提到的证书发给客户端），这两个随机数都是明文的；而第三个随机数N3（这个随机数被称为Premaster secret），客户端用数字证书的公钥进行非对称加密，发给服务器；而服务器用只有自己知道的私钥来解密，获取第三个随机数。这样，服务端和客户端都有了三个随机数N1+N2+N3，然后两端就使用这三个随机数来生成“对话密钥”，在此之后的通信都是使用这个“对话密钥”来进行对称加密解密。因为这个过程中，服务端的私钥只用来解密第三个随机数，从来没有在网络中传输过，这样的话，只要私钥没有被泄露，那么数据就是安全的。</li><li><strong>加密通信协议</strong>：就是双方商量使用哪一种加密方式，假如两者支持的加密方式不匹配，则无法进行通信；</li></ol><p>有个常见的问题，关于随机数为什么要三个？只最后一个随机数N3不可以么？<br>这是由于SSL/TLS设计，就假设服务器不相信所有的客户端都能够提供完全随机数，假如某个客户端提供的随机数不随机的话，就大大增加了“对话密钥”被破解的风险，所以由三组随机数组成最后的随机数，保证了随机数的随机性，以此来保证每次生成的“对话密钥”安全性。</p><h1 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h1><p>//哈哈 看了就是独立可费劲莱克斯顿；积分看来；士大夫</p><pre><code>SecTrustRef trust = challenge.protectionSpace.serverTrust;    SecTrustResultType result;    SecTrustSetAnchorCertificates(trust, (__bridge CFArrayRef)self.trustedCertificates);    OSStatus status = SecTrustEvaluate(trust, &amp;result);    if (status == errSecSuccess &amp;&amp; (result == kSecTrustResultProceed || result == kSecTrustResultUnspecified)) {        NSURLCredential *cred = [NSURLCredential credentialForTrust:trust];        if (cred) {            completionHandler(NSURLSessionAuthChallengeUseCredential, cred);        } else {            completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);        }    } else {        completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);    }</code></pre><p>大家应该听说过一个词叫做<a href="https://zh.wikipedia.org/wiki/中间人攻击" target="_blank" rel="noopener">中间人攻击</a>MITM(维基)。在HTTP</p><p><a href="https://lvwenhan.com/autolayout-club/478.html" target="_blank" rel="noopener">写给 iOS 开发者看的 HTTPS 指南 </a></p><p><a href="https://lvwenhan.com/操作系统/489.html" target="_blank" rel="noopener">软件工程师需要了解的网络知识：从铜线到HTTP（五）—— HTTP 和 HTTPS</a></p><p><a href="http://oncenote.com/2014/10/21/Security-1-HTTPS/" target="_blank" rel="noopener">iOS安全系列之一：HTTPS</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
